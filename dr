#!/bin/bash

# ------------------------------------------------------------------
#
#  dr : docker runner
#  manage docker containers in a simple and consistent way.
#  
#  See:
#    https://github.com/j842/dr
#
# ------------------------------------------------------------------

# Global constants.
readonly DRUSER="druser"
readonly DRGROUP="drgroup"
readonly DRETCDIR="/etc/dr"
readonly DRCFGDIR="drcfg"
readonly CFG_DIRECTORY="${DRETCDIR}/directory"
readonly CFG_IMAGENAME="${DRCFGDIR}/imagename.txt"
readonly CFG_SERVICENAME="${DRCFGDIR}/servicename.txt"
readonly REQDFILES=("txt/shorthelp.txt" "host/install" "host/destroy" "host/backup" "host/restore" "host/help" )
   
# Global variables
SERVICENAME=""
DIRECTORY=""  
DIRSERVICE=""
IMAGENAME=""


# serviceline SERVICE SHORTHELP
function serviceline {
   printf "   %-15s - %-55s\n" "$1" "$2"
}

# trim VARIABLENAME - seems to fail at /r. :/
function trim {
    read -rd '' $1 <<<"${!1}"
}

# showservices
function showservices {
   # list available services. 
   # function install here should create imagename.txt
   # the container's drinstall script should create the shorthelp.txt file
   if [ -z $DIRECTORY ]; then echo "Main directory not set - can't show services." ; exit 1 ; fi
   echo "AVAILABLE SERVICES"
   find "$DIRECTORY" -maxdepth 1 -type d | while read SERVICEPATH; do 
      if [ -e "$SERVICEPATH/txt/shorthelp.txt" ]; then
         SHORTHELP=$(<"$SERVICEPATH/txt/shorthelp.txt")
         serviceline "${SERVICEPATH##*/}" "$SHORTHELP"
      else
         if [ -e "${SERVICEPATH}/${CFG_IMAGENAME}" ]; then ***
            CONTAINERNAME=$(<"$SERVICEPATH/${CFG_IMAGENAME}")
            serviceline "${SERVICEPATH##*/}" "$IMAGENAME"
         fi
      fi
   done
}

function showusage {
cat <<'EOF' >&2

NAME
   dr - docker runner
   
SYNOPSIS
   dr configure DIRECTORY
   dr clean
   
   dr install IMAGENAME SERVICENAME
   dr backup SERVICENAME BACKUPFILE
   dr restore SERVICENAME BACKUPFILE
   dr destroy SERVICENAME
   dr shell SERVICENAME
   
   dr SERVICENAME
   dr SERVICENAME COMMAND ARGS

DESCRIPTION
   Provides a standard way to manage and run containers supporting dr.
   Intended to be used both manually and via Ansible.
   See https://github.com/j842/dr
   
EXIT CODE
   0   - success
   1   - error
   3   - no changes made
   
EOF
}

#------------------------------------------------------------------------------------

# configure
function configure {
   if [ -z $DIRECTORY ]; then echo "dr configure requires directory argument.">&2 ; exit 1 ; fi
   mkdir -p "$DRETCDIR"   # ensure directrory exists.   
   echo "$DIRECTORY" > "${CFG_DIRECTORY}"
   
   # set up standard docker user and group for containers.
   groupadd -g 22022 "$DRGROUP"
   adduser --disabled-password --gecos '' -u 22022 --gid 22022 "$DRUSER"

   mkdir -p "$DIRECTORY"   # ensure directrory exists.
   chown -R "${DRUSER}:${DRGROUP}" "$DIRECTORY"
   
   echo "Configuration complete: created druser and set up $DIRECTORY." >&2
}

# checkimage 
function checkimage {
   # Check mandatory files in image (global var IMAGENAME) before touching host. Is it a valid dr container?
   for CFILE in "${REQDFILES[@]}"; do
      docker run --rm -it ${IMAGENAME} /bin/bash -c "command -v /dr/$CFILE >/dev/null 2>&1"
      if [ "$?" -ne 0 ]; then echo "${IMAGENAME} is not Docker Runner compatible. The script ${CFILE} is missing.">&2 ; exit 1 ; fi
   done
   
   # Check running as druser.
   USERID=$(docker run --rm -it ${IMAGENAME} /bin/bash -c "id -u")
   trim USERID
   echo "[[${USERID}]]" ; echo " "
   if [ "$USERID" != "22022" ]; then echo "${IMAGENAME} is not Docker Runner compatible. Not running as druser (uid 22022). It's >>$USERID<<">&2 ; exit 1 ; fi   
}

# install
function install {
   local RVALI=0
   
   if [ -z $IMAGENAME ]; then echo "dr install requires IMAGENAME.">&2 ; exit 1 ; fi
   if [ -z $SERVICENAME ]; then echo "dr install requires SERVICENAME.">&2 ; exit 1 ; fi

   checkimage
   
   local DNAME="dr-install"

   # --- all four globals now set.

   mkdir -p "${DIRSERVICE}/cfg"

   # assumes docker image does not use entrypoint. Could instead override entrypoint maybe.
   docker run --rm -i -t --name="$DNAME" -h "${HOSTNAME}" \
               -v ${DIRSERVICE}:/tempcopy ${CONTAINERNAME} cp -a /dr/host /tempcopy && cp -a /dr/txt /tempcopy
   if [ $? -ne 0 ]; then RVALI=1 ; echo "Failed to run drinstall.">&2 ; fi  

   echo "${CONTAINERNAME}" > "${DIRSERVICE}/${CFG_IMAGENAME}"
   echo "${SERVICENAME}" > "${DIRSERVICE}/${CFG_SERVICENAME}" 
   chown -R "${DRUSER}:${DRGROUP}" "${DIRSERVICE}"
   
   # Check mandatory files made it over to host okay.
   for HFILE in "${REQDFILES[@]}"; do
      if [ ! -e "${DIRSERVICE}/${HFILE}" ]; then echo "Install failed - ${HFILE} is required" ; RVALI=1 ; fi
   done
   
   # Run the install script, e.g. to create volume containers.
   # todo: tidy up return/exit codes!         
   if [ "$RVALI" -eq 0 ]; then
      bash "${DIRSERVICE}/host/install" "${SERVICENAME}" "${IMAGENAME}"
   fi   
   
   # If we had errors then destroy everything!
   if [ "$RVALI" -ne 0 ]; then
      echo "Installation failed, destroying the partially installed service.">&2
      destroy
   fi

   exit "$RVALI"
}

# destroy
function destroy {
   if [ -z $SERVICENAME ]; then echo "dr destroy requires SERVICENAME to be set.">&2 ; exit 1 ; fi
   if [ ! -d "$DIRSERVICE" ]; then echo "The service ${SERVICENAME} does not exist.">&2 ; showservices ; exit 1 ; fi
   
   local RVALD=0

   # if the install process created a destroy script then run it, e.g. to destroy volume containers.
   # todo: tidy up return/exit codes!         
   if [ -e "${DIRSERVICE}/host/destroy" ]; then
      bash "${DIRSERVICE}/host/destroy" "${SERVICENAME}" "${IMAGENAME}"
   else 
      RVALD=1
   fi      
   
   # clean up service directory.
   rm -r "${DIRSERVICE}"
   
   exit $RVALD
}

#------------------------------------------------------------------------------------


# retriveDIRECTORY
function retrieveDIRECTORY {
   DIRERR="Run   dr configure DIRECTORY   before any other commands."
   if [ ! -d "$DRETCDIR" ]; then echo "$DIRERR">&2 ; exit 1 ; fi
   DIRECTORY=$(<"${CFG_DIRECTORY}")
   if [ -z "$DIRECTORY" ]; then echo "$DIRERR">&2 ; exit 1 ; fi
}

# setglobals
function setglobals {
   # expects SERVICENAME to be set.
   if [ -z "$SERVICENAME" ]; then "setglobals requires SERVICENAME to be set first.">&2 ; exit 1 ; fi
   retrieveDIRECTORY

   DIRSERVICE="${DIRECTORY}/${SERVICENAME}"
   if [ ! -d "$DIRSERVICE" ]; then echo "The service ${SERVICENAME} does not exist.">&2 ; showservices ; exit 1 ; fi

   IMAGENAME=$(<"${SERVICEDIR}/${CFG_IMAGENAME}") ***
   if [ -z "$IMAGENAME" ]; then echo "Error - can't read ${CFG_IMAGENAME}.">&2 ; exit 1 ; fi
}

#------------------------------------------------------------------------------------


CMD="$1" ; shift

case "$CMD" in
   configure)
      DIRECTORY="$1"
      configure
      ;;
  
   "")
      showusage
      if [ -d $DRETCDIR ]; then retrieveDIRECTORY ; showservices ; fi
      exit 0
      ;;

   clean)
      # not including -v /etc:/etc since we aren't using exclude files.
      docker run --rm -v /var/run/docker.sock:/var/run/docker.sock spotify/docker-gc
      ;;
          
   install)
      IMAGENAME="$1"
      SERVICENAME="$2"
      retrieveDIRECTORY
      DIRSERVICE="${DIRECTORY}/${SERVICENAME}"
      install
      ;;
      
   #--------------------------         
      
   destroy)
      SERVICENAME="$1" ; shift
      setglobals
      destroy 
      ;;
      
   
   *)
      # check if CMD matches a service. If so run the appropriate script.
      # format:   dr SERVICENAME COMMAND ARGS
      SERVICENAME="$CMD"
      setglobals
      
      SUBCOMMAND="$1" ; shift
      SCRIPTTORUN="${DIRSERVICE}/host/${SUBCOMMAND}"
      if [ -n "$SUBCOMMAND" ] && [ -e "${SCRIPTTORUN}" ]; then
         bash "${SCRIPTTORUN}" "${SERVICENAME}" "${IMAGENAME}" "$@"
      else
         bash "${DIRSERVICE}/host/help" "${SERVICENAME}" "${IMAGENAME}"
      fi
      ;;
esac


