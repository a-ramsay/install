#!/bin/bash

# ------------------------------------------------------------------
#
#  dr : docker runner
#  manage docker containers in a simple and consistent way.
#  
#  See:
#    https://github.com/j842/dr
#
# ------------------------------------------------------------------

if [ "$EUID" -ne 0 ]; then echo "Please run as root" ; exit 1 ; fi

# Global constants.
readonly DRUSER="druser"
readonly DRGROUP="drgroup"
readonly DRETCDIR="/etc/dr"
readonly DRCFGDIR="config"
readonly DRBINDIR="bin"
readonly CFG_DIRECTORY="${DRETCDIR}/directory"
readonly CFG_IMAGENAME="${DRCFGDIR}/imagename.txt"
readonly CFG_SERVICENAME="${DRCFGDIR}/servicename.txt"
readonly REQDFILES=("install" "destroy" "backup" "restore" "help" "enter" )
readonly COPYIMAGE="j842/dr-baseimage-alpine"
   
# Global variables
SERVICENAME=""
DIRECTORY=""  
DIRSERVICE=""
IMAGENAME=""


#------------------------------------------------------------------------------------

# serviceline SERVICE SHORTHELP
function serviceline {
   printf "   %-15s - %-55s\n" "$1" "$2"
}

#------------------------------------------------------------------------------------

# showservices
function showservices {
   # list available services. 
   # function install here should create imagename.txt
   # the container's drinstall script should create the shorthelp.txt file
   if [ -z $DIRECTORY ]; then echo "Main directory not set - can't show services." ; exit 1 ; fi
   echo "AVAILABLE SERVICES"
   find "$DIRECTORY" -maxdepth 1 -type d | while read SERVICEPATH; do 
      if [ -e "${SERVICEPATH}/${CFG_IMAGENAME}" ]; then
         SERVICEIMAGENAME=$(<"$SERVICEPATH/${CFG_IMAGENAME}")
         serviceline "${SERVICEPATH##*/}" "$SERVICEIMAGENAME"
      fi
   done
}

#------------------------------------------------------------------------------------

# showusage
function showusage {
cat <<'EOF' >&2

NAME
   dr - docker runner
   
SYNOPSIS
   dr configure DIRECTORY
   dr clean
   dr list
   
   dr install IMAGENAME SERVICENAME   
   dr update SERVICENAME
   dr destroy SERVICENAME

   PASS=? dr backup SERVICENAME BACKUPFILE
   PASS=? dr restore SERVICENAME BACKUPFILE
   
   dr SERVICENAME
   dr SERVICENAME enter
   dr SERVICENAME COMMAND ARGS

DESCRIPTION
   Provides a standard way to manage and run containers supporting dr.
   Intended to be used both manually and via Ansible.
   See https://github.com/j842/dr
   
EXIT CODE
   0   - success
   1   - error
   3   - no changes made
   
EOF
}

#------------------------------------------------------------------------------------

# command_exists
function command_exists { command -v "$1" >/dev/null 2>&1 ; }

#------------------------------------------------------------------------------------

# configure
function configure {
   if [ -z $DIRECTORY ]; then echo "dr configure requires directory argument.">&2 ; exit 1 ; fi
   mkdir -p "$DRETCDIR"   # ensure directrory exists.   
   echo "$DIRECTORY" > "${CFG_DIRECTORY}"
   
   # set up standard docker user and group for containers.
   groupadd -g 22022 "$DRGROUP"
   adduser --disabled-password --gecos '' -u 22022 --gid 22022 "$DRUSER"

   mkdir -p "$DIRECTORY"   # ensure directrory exists.
   chown -R "${DRUSER}:${DRGROUP}" "$DIRECTORY"
   
   echo "Configuration complete: created druser and set up $DIRECTORY." >&2
}

#------------------------------------------------------------------------------------

# checkimage 
function checkimage {
   # Check mandatory files in image (global var IMAGENAME) before touching host. Is it a valid dr container?
   for CFILE in "${REQDFILES[@]}"; do
      docker run --rm -it ${IMAGENAME} /bin/bash -c "command -v /dr/$CFILE >/dev/null 2>&1"
      if [ "$?" -ne 0 ]; then echo "${IMAGENAME} is not Docker Runner compatible. The script /dr/${CFILE} is missing.">&2 ; exit 1 ; fi
   done
   
   # Check running as druser.
   USERID=$(docker run --rm -it ${IMAGENAME} /bin/bash -c "id -u | tr -d '\r\n'")
   if [ "$USERID" != "22022" ]; then echo "${IMAGENAME} is not Docker Runner compatible. Not running as druser (uid 22022). It's >>$USERID<<">&2 ; exit 1 ; fi   
   
   echo "${IMAGENAME} is dr compatible.">&2
}

#------------------------------------------------------------------------------------

# createlaunchscript
function createlaunchscript {
   local SCRIPTPATH="/usr/local/bin/${SERVICENAME}"
   cat <<EOF >"$SCRIPTPATH"
#!/bin/bash
dr ${SERVICENAME} "\$@"
EOF
   chmod a+x "$SCRIPTPATH"
}

#------------------------------------------------------------------------------------

function copydrfiles {
   local UPDATEDIR="${DIRSERVICE}/${DRBINDIR}"
   if [ -d "${UPDATEDIR}" ]; then
      rm -r "${UPDATEDIR}"
   fi
   mkdir -p "${UPDATEDIR}"
   chown -R "${DRUSER}:${DRGROUP}" "${UPDATEDIR}"
   
   # assumes docker image does not use entrypoint. Could instead override entrypoint maybe.
   docker run --rm -it -v ${UPDATEDIR}:/tempcopy ${IMAGENAME} /bin/bash -c "cp -a /dr/* /tempcopy/"        
                       
   if [ $? -ne 0 ]; then 
      echo "Failed to copy files.">&2 
      rm -r "${UPDATEDIR}"
   fi  
}

#------------------------------------------------------------------------------------

# install
function install {
   local RVALI=0
   
   if [ -z $IMAGENAME ]; then echo "dr install requires IMAGENAME.">&2 ; exit 1 ; fi
   if [ -z $SERVICENAME ]; then echo "dr install requires SERVICENAME.">&2 ; exit 1 ; fi

   checkimage
   
   local DNAME="dr-install"

   # --- all four globals have been set.
   if [ -d ${DIRSERVICE} ]; then
      echo "A service is already installed at ${DIRSERVICE}. Install cancelled. You might want   dr update ${SERVICENAME}  .">&2
      exit 1
   fi
   
   copydrfiles
   
   mkdir -p "${DIRSERVICE}/${DRCFGDIR}"
   echo "${IMAGENAME}" > "${DIRSERVICE}/${CFG_IMAGENAME}"
   echo "${SERVICENAME}" > "${DIRSERVICE}/${CFG_SERVICENAME}" 
   chown -R "${DRUSER}:${DRGROUP}" "${DIRSERVICE}"
   
   # Check mandatory files made it over to host okay.
   for HFILE in "${REQDFILES[@]}"; do
      if [ ! -e "${DIRSERVICE}/${DRBINDIR}/${HFILE}" ]; then echo "Install failed - ${HFILE} is required" ; RVALI=1 ; fi
   done
   
   # create the standard config volume container.
   docker volume create --name="dr-${SERVICENAME}-config" >/dev/null
   # set permissions on config volume
   docker run --name="$DNAME" -v "dr-${SERVICENAME}-config:/config" "${COPYIMAGE}" /bin/bash -c "chown druser:drgroup /config && date >> /config/install_date"
   docker rm "$DNAME" >/dev/null 
    
   # Run the install script, e.g. to create volume containers.
   # todo: tidy up return/exit codes!         
   if [ "$RVALI" -eq 0 ]; then
      bash "${DIRSERVICE}/${DRBINDIR}/install" "${SERVICENAME}" "${IMAGENAME}"
   fi   
   
   if [ "$RVALI" -eq 0 ]; then createlaunchscript ; fi
   
   # If we had errors then destroy everything!
   if [ "$RVALI" -ne 0 ]; then
      echo "Installation failed, destroying the partially installed service.">&2
      destroy
   else 
      echo "Installation of service ${SERVICENAME} successful."
   fi

   exit "$RVALI"
}

#------------------------------------------------------------------------------------

# destroy
function destroy {
   if [ -z $SERVICENAME ]; then echo "dr destroy requires SERVICENAME to be set.">&2 ; exit 1 ; fi
   if [ ! -d "$DIRSERVICE" ]; then echo "The service ${SERVICENAME} does not exist.">&2 ; showservices ; exit 1 ; fi
   
   local RVALD=0

   # if the install process created a destroy script then run it, e.g. to destroy volume containers.
   # todo: tidy up return/exit codes!         
   if [ -e "${DIRSERVICE}/${DRBINDIR}/destroy" ]; then
      bash "${DIRSERVICE}/${DRBINDIR}/destroy" "${SERVICENAME}" "${IMAGENAME}"
   else 
      RVALD=1
   fi      
   
   # remove volume container.
   docker volume rm "dr-${SERVICENAME}-config" >/dev/null
   
   # remove launch script
   if [ -e "/usr/local/bin/${SERVICENAME}" ]; then rm "/usr/local/bin/${SERVICENAME}" ; fi
   
   # clean up service directory.
   rm -r "${DIRSERVICE}"
   
   exit $RVALD
}

#------------------------------------------------------------------------------------
# compress SOURCEFOLDER ARCHIVEFOLDER ARCHIVENAME [PASS]
function compress {
   local SOURCEFOLDER=$(realpath "$1" | tr -d '\r\n')
   if [ $? -ne 0 ]; echo "dr function compress: Couldn't find source path $1."
   local ARCHIVEFOLDER=$(realpath "$2" | tr -d '\r\n')
   if [ $? -ne 0 ]; echo "dr function compress: Couldn't find destination path $2."
   local ARCHIVEPATH="$ARCHIVEFOLDER/$3"
   local PASSCMD=""
   if [ -n "$4" ]; PASSCMD="-p${4}"; fi
   
   tar cf - -C "$SOURCEFOLDER" . | 7za a -si "${PASSCMD}" "$ARCHIVEPATH" > /dev/null
   if [ $? -ne 0 ]; then echo "Failed to create archive of $SOURCEFOLDER">&2 ; exit 1 ; fi
}

# decompress DESTFOLDER ARCHIVEFOLDER ARCHIVENAME [PASS]
function decompress {
   local DESTFOLDER=$(realpath "$1" | tr -d '\r\n')
   local ARCHIVEFOLDER=$(realpath "$2" | tr -d '\r\n')
   local ARCHIVEPATH="$ARCHIVEFOLDER/$3"

   if [ ! -e "$ARCHIVEPATH" ]; then echo "dr function decompress: No such archive: $ARCHIVEPATH">&2 ; exit 1 ; fi
   if [ ! -d "$DESTFOLDER" ]; then echo "dr function decompress: Destination folder does not exist: $DESTFOLDER">&2 ; exit 1 ; fi
   local PASSCMD=""
   if [ -n "$4" ]; PASSCMD="-p${4}"; fi
   
   7za x -so "${PASSCMD}" "${ARCHIVEPATH}" | tar xf - -C "${DESTFOLDER}"
   if [ $? -ne 0 ]; then echo "Failed to decompress archive $ARCHIVEPATH . The password may be incorrect!">&2 ; exit 1 ; fi
}

# compressvolume VOLUMENAME ARCHIVEFOLDER ARCHIVENAME
function compressvolume {
   local VOLUMENAME="$1"
   local ARCHIVEFOLDER=$(realpath "$2" | tr -d '\r\n')
   if [ $? -ne 0 ]; echo "dr function compressvolume: Couldn't find destination path $2."
   local ARCHIVENAME="$3"
   local DCNAME="dr-compressvolume"

   docker run --name="${DCNAME}" \
      -v "${VOLUMENAME}:/vol" -v "${ARCHIVEFOLDER}:/archive" "${COPYIMAGE}" \
      /bin/bash -c "tar zcf /archive/${ARCHIVENAME} -C /vol ."
   docker rm "${DCNAME}" >/dev/null 
}

# decompressvolume VOLUMENAME ARCHIVEFOLDER ARCHIVENAME
function decompressvolume {
   local VOLUMENAME="$1"
   local ARCHIVEFOLDER=$(realpath "$2" | tr -d '\r\n')
   local ARCHIVENAME="$3"
   if [ ! -e "$ARCHIVEFOLDER/$ARCHIVENAME" ]; then echo "dr function decompressvolume: Couldn't find archive $ARCHIVENAME">&2 ; exit 1 ; fi
   local DCNAME="dr-decompressvolume"

   # destroy any pre-existing data!
   docker volume rm "${VOLUMENAME}" >/dev/null
   docker volume create --name="${VOLUMENAME}" >/dev/null
   docker run --name="${DCNAME}" \
      -v "${VOLUMENAME}:/vol" -v "${ARCHIVEFOLDER}:/archive" "${COPYIMAGE}" \
      /bin/bash -c "tar zxf /archive/${ARCHIVENAME} -C /vol"
   docker rm "${DCNAME}" >/dev/null 
}

#------------------------------------------------------------------------------------

# backup BACKUPFILE
function backup {
   local BACKUPFILE=$(realpath "$1" | tr -d '\r\n')
   if [ -e "$BACKUPFILE" ]; then echo "$BACKUPFILE already exists. Aborting." ; exit 1 ; fi
   
   local TEMPROOT="$(mktemp -d)"
   local TEMPPARENT="${TEMPROOT}/backup"
   local TEMPF="${TEMPPARENT}/drbackup"
   mkdir -p "$TEMPF"
   local TEMPC="${TEMPPARENT}/containerbackup"
   mkdir -p "$TEMPC"
   chown "${DRUSER}:${DRGROUP}" "$TEMPC"
   
   # back up our configuration directory.
   compress "$DIRSERVICE/${DRCFGDIR}" "${TEMPF}" config_host.tar.7z
   
   # back up our volume container (dr-${SERVICENAME}-config).
   compressvolume "dr-${SERVICENAME}-config" "${TEMPF}" config_container.tar.7z
   
   # call through to container to backup anything there in a subfolder.
   SCRIPTTORUN="${DIRSERVICE}/${DRBINDIR}/backup"
   bash "$SCRIPTTORUN" "$SERVICENAME" "$IMAGENAME" "$TEMPC"
      
   # Compress everything with password
   compress "$TEMPPARENT" "$TEMPROOT" "backup.tar.7z" "$PASS"
   mv "$TEMPROOT/backup.tar.7z" "$BACKUPFILE"

   rm -r ${TEMPROOT}   
   echo "Backed up to $BACKUPFILE succesfully.">&2
}

#------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------


# retriveDIRECTORY
function retrieveDIRECTORY {
   DIRERR="Run   dr configure DIRECTORY   before any other commands."
   if [ ! -d "$DRETCDIR" ]; then echo "$DIRERR">&2 ; exit 1 ; fi
   DIRECTORY=$(<"${CFG_DIRECTORY}")
   if [ -z "$DIRECTORY" ]; then echo "$DIRERR">&2 ; exit 1 ; fi
   if [ ! -d "$DIRECTORY" ]; then echo "$DIRERR">&2 ; exit 1 ; fi
}

#------------------------------------------------------------------------------------

# setglobals
function setglobals {
   # expects SERVICENAME to be set.
   if [ -z "$SERVICENAME" ]; then "setglobals requires SERVICENAME to be set first.">&2 ; exit 1 ; fi
   retrieveDIRECTORY

   DIRSERVICE="${DIRECTORY}/${SERVICENAME}"
   if [ ! -d "$DIRSERVICE" ]; then echo "The service ${SERVICENAME} does not exist.">&2 ; showservices ; exit 1 ; fi

   if [ ! -e "${DIRSERVICE}/${CFG_IMAGENAME}" ]; then echo "Error - ${CFG_IMAGENAME} doesn't exist.">&2 ; exit 1 ; fi
   IMAGENAME=$(<"${DIRSERVICE}/${CFG_IMAGENAME}")
   if [ -z "$IMAGENAME" ]; then echo "Error - ${CFG_IMAGENAME} is empty.">&2 ; exit 1 ; fi
}

#------------------------------------------------------------------------------------


if ! command_exists docker ; then
   echo "Please install Docker before using Docker Runner.">&2
   echo "(e.g. use  https://github.com/j842/scripts/blob/master/install_docker.sh )">&2
   exit 1
fi
if [ $(uname -rv | grep -c "Debian") -eq 0 ]; then
   echo "This script is currently only for Debian hosts.">&2
   exit 1
fi
# Check basic commands are available
COMMANDS=(gpg wget md5sum 7z 7za)
for NEEDEDCMD in "${COMMANDS[@]}"; do
  if ! command_exists "${NEEDEDCMD}" ; then 
      echo "Docker Runner requires ${NEEDEDCMD} to be available for scripts." >&2 
      echo "After Docker is installed, install all other dependencies with: ">&2 
      echo "apt-get install -y gnupg 7zip-full">&2 
      exit 1 
  fi
done

CMD="$1" ; shift

case "$CMD" in
   configure)
      DIRECTORY="$1"
      configure
      ;;
  
   "")
      showusage
      if [ -d $DRETCDIR ]; then retrieveDIRECTORY ; showservices ; fi
      exit 0
      ;;

   clean)
      # not including -v /etc:/etc since we aren't using exclude files.
      docker run --rm -v /var/run/docker.sock:/var/run/docker.sock spotify/docker-gc
      ;;
          
   install)
      IMAGENAME="$1"
      SERVICENAME="$2"
      retrieveDIRECTORY
      DIRSERVICE="${DIRECTORY}/${SERVICENAME}"
      install
      ;;
      
   update)
      SERVICENAME="$1"
      setglobals
      copydrfiles
      ;;
      
   # dr backup SERVICENAME BACKUPFILE
   backup)
      SERVICENAME="$1"
      setglobals
      backup "$2"
      ;;
     
   # dr restore SERVICENAME BACKUPFILE
   restore)
      SERVICENAME="$1"
      retrieveDIRECTORY
      restore "$2"
      ;;
      
   list)
      retrieveDIRECTORY
      showservices
      ;;
      
   #--------------------------         
      
   destroy)
      SERVICENAME="$1" ; shift
      setglobals
      destroy 
      ;;
      
   
   *)
      # check if CMD matches a service. If so run the appropriate script.
      # format:   dr SERVICENAME COMMAND ARGS
      SERVICENAME="$CMD"
      setglobals
      
      SUBCOMMAND="$1" ; shift
      SCRIPTTORUN="${DIRSERVICE}/${DRBINDIR}/${SUBCOMMAND}"
      if [ -n "$SUBCOMMAND" ] && [ -e "${SCRIPTTORUN}" ]; then
         bash "${SCRIPTTORUN}" "${SERVICENAME}" "${IMAGENAME}" "$@"
      else
         bash "${DIRSERVICE}/${DRBINDIR}/help" "${SERVICENAME}" "${IMAGENAME}"
      fi
      ;;
esac


