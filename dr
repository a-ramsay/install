#!/bin/bash

# ------------------------------------------------------------------
#
#  dr : docker runner
#  manage docker containers in a simple and consistent way.
#  
#  See:
#    https://github.com/j842/dr
#
# ------------------------------------------------------------------

if [ "$EUID" -ne 0 ]; then echo "Please run as root" ; exit 1 ; fi

# Global constants.
readonly DRUSER="druser"
readonly DRGROUP="drgroup"
readonly DRETCDIR="/etc/dr"
readonly DRCFGDIR="config"
readonly DRBINDIR="bin"
readonly CFG_DIRECTORY="${DRETCDIR}/directory"
readonly CFG_IMAGENAME="${DRCFGDIR}/imagename.txt"
readonly CFG_SERVICENAME="${DRCFGDIR}/servicename.txt"
readonly REQDFILES=("install" "destroy" "backup" "restore" "help" "enter" )
   
# Global variables
SERVICENAME=""
DIRECTORY=""  
DIRSERVICE=""
IMAGENAME=""


# serviceline SERVICE SHORTHELP
function serviceline {
   printf "   %-15s - %-55s\n" "$1" "$2"
}

# showservices
function showservices {
   # list available services. 
   # function install here should create imagename.txt
   # the container's drinstall script should create the shorthelp.txt file
   if [ -z $DIRECTORY ]; then echo "Main directory not set - can't show services." ; exit 1 ; fi
   echo "AVAILABLE SERVICES"
   find "$DIRECTORY" -maxdepth 1 -type d | while read SERVICEPATH; do 
      if [ -e "${SERVICEPATH}/${CFG_IMAGENAME}" ]; then
         SERVICEIMAGENAME=$(<"$SERVICEPATH/${CFG_IMAGENAME}")
         serviceline "${SERVICEPATH##*/}" "$SERVICEIMAGENAME"
      fi
   done
}

function showusage {
cat <<'EOF' >&2

NAME
   dr - docker runner
   
SYNOPSIS
   dr configure DIRECTORY
   dr clean
   
   dr install IMAGENAME SERVICENAME   
   dr update SERVICENAME
   dr backup SERVICENAME BACKUPFILE
   dr restore SERVICENAME BACKUPFILE
   dr destroy SERVICENAME
   
   dr SERVICENAME
   dr SERVICENAME shell
   dr SERVICENAME COMMAND ARGS

DESCRIPTION
   Provides a standard way to manage and run containers supporting dr.
   Intended to be used both manually and via Ansible.
   See https://github.com/j842/dr
   
EXIT CODE
   0   - success
   1   - error
   3   - no changes made
   
EOF
}

#------------------------------------------------------------------------------------

# configure
function configure {
   if [ -z $DIRECTORY ]; then echo "dr configure requires directory argument.">&2 ; exit 1 ; fi
   mkdir -p "$DRETCDIR"   # ensure directrory exists.   
   echo "$DIRECTORY" > "${CFG_DIRECTORY}"
   
   # set up standard docker user and group for containers.
   groupadd -g 22022 "$DRGROUP"
   adduser --disabled-password --gecos '' -u 22022 --gid 22022 "$DRUSER"

   mkdir -p "$DIRECTORY"   # ensure directrory exists.
   chown -R "${DRUSER}:${DRGROUP}" "$DIRECTORY"
   
   echo "Configuration complete: created druser and set up $DIRECTORY." >&2
}

# checkimage 
function checkimage {
   # Check mandatory files in image (global var IMAGENAME) before touching host. Is it a valid dr container?
   for CFILE in "${REQDFILES[@]}"; do
      docker run --rm -it ${IMAGENAME} /bin/bash -c "command -v /dr/$CFILE >/dev/null 2>&1"
      if [ "$?" -ne 0 ]; then echo "${IMAGENAME} is not Docker Runner compatible. The script /dr/${CFILE} is missing.">&2 ; exit 1 ; fi
   done
   
   # Check running as druser.
   USERID=$(docker run --rm -it ${IMAGENAME} /bin/bash -c "id -u | tr -d '\r\n'")
   if [ "$USERID" != "22022" ]; then echo "${IMAGENAME} is not Docker Runner compatible. Not running as druser (uid 22022). It's >>$USERID<<">&2 ; exit 1 ; fi   
   
   echo "${IMAGENAME} is dr compatible.">&2
}

# createlaunchscript
function createlaunchscript {
   local SCRIPTPATH="/usr/local/bin/${SERVICENAME}"
   cat <<EOF >"$SCRIPTPATH"
#!/bin/bash
dr ${SERVICENAME} "\$@"
EOF
   chmod a+x "$SCRIPTPATH"
}

function copydrfiles {
   local UPDATEDIR="${DIRSERVICE}/${DRBINDIR}"
   if [ -d "${UPDATEDIR}" ]; then
      rm -r "${UPDATEDIR}"
   fi
   mkdir -p "${UPDATEDIR}"
   chown -R "${DRUSER}:${DRGROUP}" "${UPDATEDIR}"
   
   # assumes docker image does not use entrypoint. Could instead override entrypoint maybe.
   docker run --rm -it -v ${UPDATEDIR}:/tempcopy ${IMAGENAME} /bin/bash -c "cp -a /dr/* /tempcopy/"        
                       
   if [ $? -ne 0 ]; then 
      echo "Failed to copy files.">&2 
      rm -r "${UPDATEDIR}"
   fi  
}

# install
function install {
   local RVALI=0
   
   if [ -z $IMAGENAME ]; then echo "dr install requires IMAGENAME.">&2 ; exit 1 ; fi
   if [ -z $SERVICENAME ]; then echo "dr install requires SERVICENAME.">&2 ; exit 1 ; fi

   checkimage
   
   local DNAME="dr-install"

   # --- all four globals have been set.
   if [ -d ${DIRSERVICE} ]; then
      echo "A service is already installed at ${DIRSERVICE}. Install cancelled. You might want   dr update ${SERVICENAME}  .">&2
      exit 1
   fi
   
   copydrfiles
   
   mkdir -p "${DIRSERVICE}/${DRCFGDIR}"
   echo "${IMAGENAME}" > "${DIRSERVICE}/${CFG_IMAGENAME}"
   echo "${SERVICENAME}" > "${DIRSERVICE}/${CFG_SERVICENAME}" 
   chown -R "${DRUSER}:${DRGROUP}" "${DIRSERVICE}"
   
   # Check mandatory files made it over to host okay.
   for HFILE in "${REQDFILES[@]}"; do
      if [ ! -e "${DIRSERVICE}/${DRBINDIR}/${HFILE}" ]; then echo "Install failed - ${HFILE} is required" ; RVALI=1 ; fi
   done
   
   # create the standard config volume container.
   docker volume create --name="dr-${SERVICENAME}-config"
   # set permissions on config volume
   docker run --name="$DNAME" -v "dr-${SERVICENAME}-config:/config" j842/dr-baseimage-alpine /bin/bash -c "chown druser:drgroup /config && date >> /config/install_date"
   docker rm "$DNAME" >/dev/null 2>&1
    
   # Run the install script, e.g. to create volume containers.
   # todo: tidy up return/exit codes!         
   if [ "$RVALI" -eq 0 ]; then
      bash "${DIRSERVICE}/${DRBINDIR}/install" "${SERVICENAME}" "${IMAGENAME}"
   fi   
   
   if [ "$RVALI" -eq 0 ]; then createlaunchscript ; fi
   
   # If we had errors then destroy everything!
   if [ "$RVALI" -ne 0 ]; then
      echo "Installation failed, destroying the partially installed service.">&2
      destroy
   fi

   exit "$RVALI"
}

# destroy
function destroy {
   if [ -z $SERVICENAME ]; then echo "dr destroy requires SERVICENAME to be set.">&2 ; exit 1 ; fi
   if [ ! -d "$DIRSERVICE" ]; then echo "The service ${SERVICENAME} does not exist.">&2 ; showservices ; exit 1 ; fi
   
   local RVALD=0

   # if the install process created a destroy script then run it, e.g. to destroy volume containers.
   # todo: tidy up return/exit codes!         
   if [ -e "${DIRSERVICE}/${DRBINDIR}/destroy" ]; then
      bash "${DIRSERVICE}/${DRBINDIR}/destroy" "${SERVICENAME}" "${IMAGENAME}"
   else 
      RVALD=1
   fi      
   
   # remove volume container.
   docker volume rm --name="dr-${SERVICENAME}-config"
   
   # remove launch script
   if [ -e "/usr/local/bin/${SERVICENAME}" ]; then rm "/usr/local/bin/${SERVICENAME}" ; fi
   
   # clean up service directory.
   rm -r "${DIRSERVICE}"
   
   exit $RVALD
}

#------------------------------------------------------------------------------------


# retriveDIRECTORY
function retrieveDIRECTORY {
   DIRERR="Run   dr configure DIRECTORY   before any other commands."
   if [ ! -d "$DRETCDIR" ]; then echo "$DIRERR">&2 ; exit 1 ; fi
   DIRECTORY=$(<"${CFG_DIRECTORY}")
   if [ -z "$DIRECTORY" ]; then echo "$DIRERR">&2 ; exit 1 ; fi
   if [ ! -d "$DIRECTORY" ]; then echo "$DIRERR">&2 ; exit 1 ; fi
}

# setglobals
function setglobals {
   # expects SERVICENAME to be set.
   if [ -z "$SERVICENAME" ]; then "setglobals requires SERVICENAME to be set first.">&2 ; exit 1 ; fi
   retrieveDIRECTORY

   DIRSERVICE="${DIRECTORY}/${SERVICENAME}"
   if [ ! -d "$DIRSERVICE" ]; then echo "The service ${SERVICENAME} does not exist.">&2 ; showservices ; exit 1 ; fi

   if [ ! -e "${DIRSERVICE}/${CFG_IMAGENAME}" ]; then echo "Error - ${CFG_IMAGENAME} doesn't exist.">&2 ; exit 1 ; fi
   IMAGENAME=$(<"${DIRSERVICE}/${CFG_IMAGENAME}")
   if [ -z "$IMAGENAME" ]; then echo "Error - ${CFG_IMAGENAME} is empty.">&2 ; exit 1 ; fi
}

#------------------------------------------------------------------------------------


CMD="$1" ; shift

case "$CMD" in
   configure)
      DIRECTORY="$1"
      configure
      ;;
  
   "")
      showusage
      if [ -d $DRETCDIR ]; then retrieveDIRECTORY ; showservices ; fi
      exit 0
      ;;

   clean)
      # not including -v /etc:/etc since we aren't using exclude files.
      docker run --rm -v /var/run/docker.sock:/var/run/docker.sock spotify/docker-gc
      ;;
          
   install)
      IMAGENAME="$1"
      SERVICENAME="$2"
      retrieveDIRECTORY
      DIRSERVICE="${DIRECTORY}/${SERVICENAME}"
      install
      ;;
      
   update)
      SERVICENAME="$1"
      setglobals
      copydrfiles
      ;;
      
   # dr backup SERVICENAME BACKUPFILE
   backup)
      SERVICENAME="$1"
      setglobals
      ;;
     
   # dr restore SERVICENAME BACKUPFILE
   restore)
      SERVICENAME="$1"
      retrieveDIRECTORY
      ;;
      
   #--------------------------         
      
   destroy)
      SERVICENAME="$1" ; shift
      setglobals
      destroy 
      ;;
      
   
   *)
      # check if CMD matches a service. If so run the appropriate script.
      # format:   dr SERVICENAME COMMAND ARGS
      SERVICENAME="$CMD"
      setglobals
      
      SUBCOMMAND="$1" ; shift
      SCRIPTTORUN="${DIRSERVICE}/${DRBINDIR}/${SUBCOMMAND}"
      if [ -n "$SUBCOMMAND" ] && [ -e "${SCRIPTTORUN}" ]; then
         bash "${SCRIPTTORUN}" "${SERVICENAME}" "${IMAGENAME}" "$@"
      else
         bash "${DIRSERVICE}/${DRBINDIR}/help" "${SERVICENAME}" "${IMAGENAME}"
      fi
      ;;
esac


